# Data Model: Row-Based UI Mode

**Feature**: 004-row-ui | **Date**: 2025-11-05

## Overview

This feature primarily affects the UI presentation layer and introduces configuration persistence. No changes are made to the existing Task or Column data models in the database.

## Entity Changes

### New Entities

#### Config

**Purpose**: Store user preferences that persist between application sessions.

**Location**: `~/.config/ontop/ontop.toml` (filesystem, not database)

**Format**: TOML

**Schema**:
```toml
# OnTop Configuration
# Auto-generated by application

[ui]
view_mode = "column"  # or "row"
```

**Fields**:

| Field | Type | Required | Default | Validation | Description |
|-------|------|----------|---------|------------|-------------|
| ui.view_mode | string | Yes | "column" | Must be "column" or "row" | Preferred view layout mode |

**Future Extensions** (out of scope for this feature):
```toml
[ui]
view_mode = "row"
theme = "gruvbox"  # Future: theme selection
show_help = true   # Future: help visibility

[behavior]
sort_mode = "priority"  # Future: default sort mode
```

### Modified Entities

#### Model (TUI State - `internal/tui/model.go`)

**Purpose**: Add view layout state to existing TUI model.

**New Fields**:

| Field | Type | Description | Lifecycle |
|-------|------|-------------|-----------|
| viewLayout | ViewLayout | Current layout mode (column or row) | Session state, initialized from config |
| rowScrollOffset | map[int]int | Horizontal scroll offset per row (0=inbox, 1=in_progress, 2=done) | Session state, reset on layout toggle |

**Type Definitions**:
```go
// ViewLayout represents the visual organization of the kanban board
type ViewLayout int

const (
    LayoutColumn ViewLayout = iota  // Vertical columns (existing)
    LayoutRow                       // Horizontal rows (new)
)
```

**Relationship to Existing Fields**:
- `viewMode ViewMode` (existing): Unchanged - still tracks Kanban/Detail/Move/Create/Edit
- `viewLayout ViewLayout` (new): Orthogonal - controls rendering within Kanban mode
- Both can vary independently: e.g., ViewModeKanban + LayoutRow

### Unchanged Entities

#### Task (`internal/models/task.go`)

**Status**: No changes

**Rationale**: View layout is presentation concern only. Task data structure, storage, and business logic remain identical regardless of how tasks are visualized.

#### Column Workflow

**Status**: No changes

**Values**: inbox, in_progress, done (unchanged)

**Rationale**: Row-based view simply displays these three columns as horizontal rows instead of vertical columns. The workflow state machine is unaffected.

## State Transitions

### View Layout Lifecycle

```
Application Start
    ↓
Load Config (~/.config/ontop/ontop.toml)
    ↓
Initialize viewLayout = config.ui.view_mode
    ↓
┌─────────────────────────────────────┐
│                                     │
│  User presses 'v' (toggle)          │
│        ↓                            │
│  viewLayout = toggle(viewLayout)    │
│        ↓                            │
│  Save config.ui.view_mode           │
│        ↓                            │
│  Reset rowScrollOffset to {}        │
│        ↓                            │
│  Re-render view                     │
│        ↓                            │
└─────────────────────────────────────┘
         (loop)
```

### Config Persistence Flow

```
Load on Startup:
1. Check if ~/.config/ontop/ontop.toml exists
2. If exists: Parse TOML → Config struct
3. If not exists or parse error: Use defaults (view_mode="column")
4. Apply config.ui.view_mode to Model.viewLayout

Save on Toggle:
1. User presses 'v'
2. Toggle viewLayout in memory
3. Create ~/.config/ontop/ if not exists (MkdirAll)
4. Marshal Config struct to TOML
5. Write to temp file
6. Atomic rename temp → ontop.toml
7. Log error if write fails (non-fatal)
8. Continue with new viewLayout regardless
```

### Row Scroll Offset Management

```
rowScrollOffset: map[int]int
    Key: Row index (0=inbox, 1=in_progress, 2=done)
    Value: Leftmost visible task index

Initialization:
- Empty map {} (all offsets implicitly 0)

Update Triggers:
- Left arrow in row mode: offset = max(0, offset-1)
- Right arrow in row mode: offset = min(maxOffset, offset+1)
- Row change (up/down): Preserve offset for each row
- Layout toggle: Clear map (reset all offsets to 0)
- Task move: Preserve offset (may adjust if selected task moves)

Bounds:
- maxOffset = max(0, len(tasks)-visibleCount)
- visibleCount = (terminalWidth - decorations) / cardWidth
```

## Validation Rules

### Config Validation

| Rule | Field | Validation | Error Handling |
|------|-------|------------|----------------|
| CV-001 | ui.view_mode | Must be "column" or "row" | Default to "column" on invalid value, log warning |
| CV-002 | File format | Valid TOML syntax | Default to "column" on parse error, log warning |
| CV-003 | File permissions | Readable/writable by user | Log error, continue with in-memory state |

### Model State Validation

| Rule | Field | Validation | Error Handling |
|------|-------|------------|----------------|
| MV-001 | viewLayout | Must be LayoutColumn or LayoutRow | Compiler-enforced (type-safe enum) |
| MV-002 | rowScrollOffset keys | Must be 0, 1, or 2 | Runtime check, ignore invalid keys |
| MV-003 | rowScrollOffset values | Must be >= 0 | Max with 0 on read |

## Data Flow

### Config to UI Flow

```
Filesystem                  Application Memory                TUI Rendering
~/.config/ontop/ontop.toml → Config struct → Model.viewLayout → renderKanbanColumns()
                                                              → renderKanbanRows()
```

### UI to Config Flow

```
User Input → Key Handler → Model.viewLayout updated → Config struct updated → Write TOML
                                ↓
                          Trigger re-render
```

### Task Data Flow (Unchanged)

```
SQLite (~/.ontop/tasks.db) → storage.ListTasks() → Model.tasks → Rendered by current layout
                                                                    (column or row)
```

**Key Insight**: Task data flow is independent of view layout. Both layouts consume the same `Model.tasks` slice, just render it differently.

## Storage Schema

### Filesystem Structure

```
~/.config/ontop/
├── ontop.toml           # User preferences (view_mode, future settings)
└── ontop.toml.tmp       # Temp file during atomic write (deleted after rename)

~/.ontop/
└── tasks.db             # Existing SQLite database (unchanged)
```

### Config File Example

```toml
# OnTop Configuration
# Generated: 2025-11-05T14:32:10Z

[ui]
view_mode = "row"
```

### Permissions

| Path | Permissions | Owner | Notes |
|------|-------------|-------|-------|
| ~/.config/ontop/ | 0755 (drwxr-xr-x) | User | Directory accessible to user only |
| ~/.config/ontop/ontop.toml | 0644 (-rw-r--r--) | User | Readable by user, writable by user |

## Relationships

### Entity Relationship Diagram

```
┌─────────────────┐
│  Config (TOML)  │
│  ~/.config/...  │
└────────┬────────┘
         │ loads into
         ↓
┌─────────────────┐
│  Model.State    │
│  (TUI memory)   │
│  - viewLayout   │
│  - rowScroll    │
└────────┬────────┘
         │ determines
         ↓
┌─────────────────────────┐
│  Rendering Functions    │
│  - renderKanbanColumns()│
│  - renderKanbanRows()   │
└─────────────────────────┘
         │ display
         ↓
┌─────────────────┐
│  Task Entities  │
│  (from SQLite)  │
│  (unchanged)    │
└─────────────────┘
```

**Key Point**: Config and Task data are independent. Config affects presentation, Task data is layout-agnostic.

## Migration Strategy

### Backwards Compatibility

**Scenario**: User has existing OnTop installation without config file

**Behavior**:
1. First launch after upgrade: Config file doesn't exist
2. Application uses default (LayoutColumn)
3. User experience unchanged from pre-feature behavior
4. When user first toggles to row mode: Config file is created
5. Future launches respect saved preference

**No Migration Script Needed**: Config is optional, defaults are safe.

### Forward Compatibility

**Scenario**: Future features add new config fields

**Strategy**:
- Use TOML's flexibility for optional fields
- Always provide defaults in code
- Unknown fields in TOML are ignored (TOML parser behavior)
- Example:
  ```toml
  [ui]
  view_mode = "row"
  future_field = "value"  # Ignored by current version
  ```

## Testing Considerations

### Data Model Tests

1. **Config Persistence**:
   - Write config → read back → verify values match
   - Invalid view_mode → defaults to "column"
   - Missing config file → defaults to "column"
   - Malformed TOML → defaults to "column"

2. **State Transitions**:
   - Toggle column → row → column → verify state correct
   - rowScrollOffset cleared on layout toggle
   - Config written on every toggle

3. **Edge Cases**:
   - Config directory doesn't exist → created automatically
   - Config file read-only → error logged, app continues
   - Concurrent writes (unlikely but possible) → last write wins

### Integration Tests

1. **Full Lifecycle**:
   - Start app → verify default column layout
   - Toggle to row → verify config written
   - Exit app → restart → verify row layout persisted

2. **Cross-Mode Consistency**:
   - Move task in column mode → toggle to row → verify task moved
   - Select task in row mode → toggle to column → verify task selected

## Performance Considerations

### Config I/O

- **Load**: Once per application start (~1ms)
- **Save**: Once per layout toggle (~1ms)
- **Impact**: Negligible (config file <1KB, infrequent writes)

### Memory

- **Config struct**: ~100 bytes
- **rowScrollOffset map**: ~100 bytes (3 rows × ~30 bytes per entry)
- **Total overhead**: <500 bytes (negligible)

### Rendering

- **Layout toggle**: Full re-render required (~16ms @ 60fps)
- **Scroll navigation**: Partial re-render (same performance as task navigation)
- **Impact**: No perceptible difference from existing column navigation

## Summary

- **New persistent data**: Config file with view_mode preference
- **New session data**: ViewLayout state, row scroll offsets
- **Unchanged data**: Task entities, Column workflow, SQLite database
- **Storage**: Filesystem (TOML) for config, memory for UI state
- **Validation**: Defensive defaults, non-fatal errors
- **Compatibility**: Fully backward compatible, graceful degradation
